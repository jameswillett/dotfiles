:{
  join' :: String -> [String] -> String
  join' str l
    | length l > 1  = (head l) ++ str ++ join' str (tail l)
    | otherwise     = head l


  wordsWhen :: (Char -> Bool) -> String -> [String]
  wordsWhen p s =  case dropWhile p s of
    "" -> []
    s' -> w : wordsWhen p s''
      where (w, s'') = break p s'

  abbrvModule :: String -> String
  abbrvModule = join' "." . map ((:"") . head) . wordsWhen (=='.')

  greyBG      = "\ESC[48;5;238m\STX"
  greyFG      = "\ESC[38;5;238m"
  blueFG      = "\ESC[38;5;39m"
  pinkFG      = "\ESC[1;35m\STX"
  blankBG     = "\ESC[1;49m"
  lightGreyFG = "\ESC[38;5;245m"

  pf :: [String] -> Int -> IO String
  pf modules line = return (left ++ mods ++ right)
    where
      showSeparator = if length modules > 0 then (lightGreyFG ++ "\57521 ") else ""
      left = blueFG ++ greyBG ++ " λ " ++ showSeparator ++ pinkFG
      mods = join' (" " ++ blueFG ++ "| " ++ pinkFG) $ map abbrvModule modules;
      right = " " ++ greyFG ++ blankBG ++ "\57520 \ESC[m\STX"
:}

-- :set prompt "\ESC[38;5;39m\ESC[48;5;240m\STX λ :: \ESC[1;35m\STX%s \ESC[38;5;240m\ESC[1;49m \ESC[m\STX"
:set prompt-cont "...  "
:set prompt-function pf

-- OverloadedStrings is often useful.
:set -XOverloadedStrings

-- Scoped type variables is often useful so we can specify the types
-- of variables (for example, in lambda expressions).
:set -XScopedTypeVariables

-- useful for import from specified package
:set -XPackageImports

-- Show the types of evaluated expressions
:set +t

-- And stats
:set +s

-- Enable multi-line expressions with :{ and :}
:set +m
